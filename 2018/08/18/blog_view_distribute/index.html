<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>View的事件体系简述 | 融易通兴业团队</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">View的事件体系简述</h1><a id="logo" href="/.">融易通兴业团队</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">View的事件体系简述</h1><div class="post-meta">Aug 18, 2018<span> | </span><span class="category"><a href="/categories/彭连/">彭连</a></span></div><div class="post-content"><h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><h3 id="什么是View"><a href="#什么是View" class="headerlink" title="什么是View"></a>什么是View</h3><p>View是Android中所有控件的基类，不管是简单的Button以及TextView还是复杂的RelativeLayout与ListView，它们的共同基类都是View。所以说View是一种界面层的控件的一种抽象，它代表了一个控件。除了View，还有ViewGroup，顾名思义，它内部包含了很多控件，ViewGroup也是继承自View，这意味着View本身就可以是单个控件也可以是多个控件组成的一组控件，通过这种关系就形成了View树的结构，这个和Web中的DOM树的概念很相似。View就相当于Dom中的节点，它可以是单个的View，也可以是包含View的ViewGroup。所以说Android界面构成实质上就是View树的绘制。</p>
<h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>View的位置主要由它的四个顶点来决定，分别对应于View的四个属性：top、left、right、buttom，其中（left,top）代表左上角的坐标，(right,bottom)代表右下角的坐标,需要注意的是，这些坐标都是相对于父容器来说的，它是一种相对坐标，View的坐标和父容器的关系如下图：</p>
<p><img src="/img/pl/view_relation.png" alt=""></p>
<p>在Android中，x轴和Y轴的正方向分别为向右与向下，这点不难理解，不仅仅是Android，大部分显示系统都是按照这个标准来定义坐标的。由图可知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width = right - left;</span><br><span class="line">height = bottom - top;</span><br></pre></td></tr></table></figure></p>
<p>View的四个参数对应的获取方法分别为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left = getLeft();</span><br><span class="line">right = getRight();</span><br><span class="line">top = getTop();</span><br><span class="line">bottom = getBottom();</span><br></pre></td></tr></table></figure></p>
<p>在Android3.0新增了几个参数，x、y、translationX以及translationY,其中x与y是View左上角的坐标，而translationX与translationY是View左上角相对于父容器的偏移量，这几个参数也是相对于父容器，而translationX与translationY的默认值为0，和View的四个基本参数一样，View也为其提供了get/set方法，这个参数的换算关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = left + translationX;</span><br><span class="line">y = top + translationY;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，在平移的过程中，top与left分别代表的是原始左上角的位置信息，其值并不会改变，此时变化的是x、y、translationX以及translationY这四个参数。</p>
<h3 id="MotionEvent与TouchSlop"><a href="#MotionEvent与TouchSlop" class="headerlink" title="MotionEvent与TouchSlop"></a>MotionEvent与TouchSlop</h3><h4 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h4><p>在手指触摸屏幕后所产生的一系列事件中，典型的事件类型有以下几种：</p>
<ul>
<li>ACTION_DOWN——手指刚接触屏幕</li>
<li>ACTION_MOVE——手指在屏幕滑动</li>
<li>ACTION_UP——手指从屏幕上松开的瞬间</li>
</ul>
<p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况：</p>
<ul>
<li>点击屏幕后松开，事件顺序为DOWM——UP;</li>
<li>点击屏幕后滑动一会松开，事件顺序为DOWN——MOVE——MOVE…——UP；</li>
</ul>
<p>上述三种情况是典型的事件序列，通过可以通过MotionEvent得到点击事件发生的x以及Y坐标。为此，系统提供了两组方法：getX/getY以及getRawX/getRawY。它们的区别很简单，前者返回的是相对于当前View左上角的x和y的坐标，而后者返回的是相对于手机屏幕左上角的x和y的坐标</p>
<h4 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h4><p>TouchSlop是系统所能识别出的被认为是滑动的最小距离，换句话说，当手指在屏幕上滑动时，如果两次的滑动之间的距离小于这个常量,那么系统就不认为你是在进行滑动操作。原因很简单，滑动距离太小，系统不认为这是一个滑动操作。这是一个常量，和设备有关，在不同的设备上这个值可能是不同的，通过如下方式可以获取这个常量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewConfigution.get(getContext()).getScaleTouchSlop()</span><br></pre></td></tr></table></figure></p>
<p>这个常量有什么意义呢？当我们在处理滑动时，可以利用这个常量来做一些过滤，比如当两次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值，因此就可以认为它们不是滑动，这样做可以有更好的用户体验。</p>
<h3 id="VelocityTracker、GestureDetector和Scroller"><a href="#VelocityTracker、GestureDetector和Scroller" class="headerlink" title="VelocityTracker、GestureDetector和Scroller"></a>VelocityTracker、GestureDetector和Scroller</h3><h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h4><p>速度追踪，用于追踪手指在滑动过程中的速度，包括水平与垂直方向的速度。它的使用过程很简单，首先，在View的onTouchEvent方法中追踪当前点击事件的速度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//表示单位时间内像素数</span><br><span class="line">VelocityTracker velocityTracker = VelocityTracker.obtain();</span><br><span class="line">velocityTracker.addMovement(event);</span><br><span class="line">velocityTracker.computeCurrentVelocity(1000);</span><br><span class="line">int xVelocity = (int)velocityTracker.getXVelocity();</span><br><span class="line">int yVelocity = (int)velocityTracker.getYVelocity();</span><br><span class="line"></span><br><span class="line">// 不用的话就将其释放</span><br><span class="line">velocityTracker.clear();</span><br><span class="line">velocityTracker.recycle();</span><br></pre></td></tr></table></figure></p>
<h4 id="gestureDetector"><a href="#gestureDetector" class="headerlink" title="gestureDetector"></a>gestureDetector</h4><p>手势检测，用于辅助检测用户的单机、滑动、长按、双击等行为。使用GestureDetector很简单，只需要创建一个GestureDetector对象并且实现OnGestureListener接口，接着接管onTouchEvent方法，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector mGestureDetector = new GesTureDector(this);</span><br><span class="line">//解决长按屏幕无法拖动的现象</span><br><span class="line">mGestureDetector.setIsLongpressEnabled(false);</span><br><span class="line">//在待监听的View的onTouchEvent方法中实现如下：</span><br><span class="line">boolean consume = mGestureDetector.onTouchEvent(event);</span><br><span class="line">return consume;</span><br></pre></td></tr></table></figure></p>
<p>当然，OnGestureListener还有很多回调方法，这里就不一一介绍了。</p>
<h4 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h4><p>弹性滑动对象，用于实现View的弹性滑动。我们知道，当使用View的scrollBy或者scrollTo方法来进行滑动时，其过程时瞬间完成的，这个没有过渡效果的滑动用户体验不好。它的典型代码时固定的，具体实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Scroller scroller = new Scroller(mContext);</span><br><span class="line">//缓慢滑动到指定位置</span><br><span class="line">private void smoothScroller(int destX, int destY)&#123;</span><br><span class="line">    int scrollX = getScrollX();</span><br><span class="line">    int delta = destX - scrollX;</span><br><span class="line">    //1000ms内滑动到destX,效果就是慢慢滑动</span><br><span class="line">    mScroller.startScroll(scrollX,0,delta,0,1000);</span><br><span class="line">    //startScroll只是做了更新数据，真正进行滑动是由invalidate()方法执行的</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void computeScroll()&#123;</span><br><span class="line">    if(mScroller.computeScrollOffset())&#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>补充说明以下，弹性滑动除了可以使用Scroller实现，还可以使用动画以及延时策略。使用动画只要为其设置一个执行动画的时间值即可，而延迟策略就是采用postDelay或者sleep等方法延迟执行滑动动作，从而可以实现弹性滑动的效果。</p>
<h2 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h2><p>View的滑动，在Android设备上，滑动几乎是应用的标配，不管是下拉刷新还是SlidingMenu，它们的基础都是滑动。从另一方面说，Android手机屏幕比较小，为了给用户呈现更多的内容，就需要滑动来显示与隐藏一些内容。由此可见，滑动在Android开发中是多么的重要。</p>
<h3 id="scrollTo与scrollBy"><a href="#scrollTo与scrollBy" class="headerlink" title="scrollTo与scrollBy"></a>scrollTo与scrollBy</h3><p>scrollTo与scrollBy是View提供的两个实现滑动的方法，scrollBy的内部实现也是scrollTo，只是入参不同而已，只不过scrollBy是基于当前位置的滑动，而scrollTo是基于所传参数的绝对滑动。</p>
<h3 id="使用动画"><a href="#使用动画" class="headerlink" title="使用动画"></a>使用动画</h3><p>动画本身就支持平移等操作，平移就是一种滑动，使用动画来移动View,主要就是操作View的translationX以及translationY属性，既可以使用传统的View动画，也可以使用属性动画（属性动画是在Android3.0引入的，如果对Android版本要求不高，优先使用属性动画。）</p>
<h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><p>改变布局参数，即改变LayoutParam。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarginLayoutParam param = (MarginLayoutParam)button.getLayoutParam();</span><br><span class="line">param.width += 10;</span><br><span class="line">param.leftMargin += 100;</span><br><span class="line">button.setLayoutParam(param);</span><br><span class="line">//或者button.requestLayout()；</span><br></pre></td></tr></table></figure></p>
<h3 id="各种滑动方式对比"><a href="#各种滑动方式对比" class="headerlink" title="各种滑动方式对比"></a>各种滑动方式对比</h3><p>先看scrollTo/scrollBy这种方式，它是View提供的原生的方法，其作用是专门用于View的滑动，它可以比较方便的实现滑动效果并且不影响内部元素的点击事件。但它的最大缺点也是很显然：它只能滑动View的内容，不能滑动View本身以及View在布局中的位置。</p>
<p>动画来实现滑动的话，要分情况，如果是Android3.0以上的话，用属性动画来实现，没有什么明显的缺点；如果是View的动画或者在Android3.0以下使用属性动画，均不能改变View的属性。在实际使用中，如果动画不影响交互的话，那么使用动画来做滑动是比较合适的，否则不合适。但是动画有个很明显的优点，那就是一些复杂的效果必须要用动画来实现。</p>
<p>使用改变布局的这种方式，除了使用起来比较麻烦，也没有明显的缺点，它的主要适用对象是一些具有交互性的View，因为这些View需要和用户交互，使用动画就会有问题。</p>
<p>所以总结以下就是：</p>
<ul>
<li>scrollTo/scrollBy:操作简单，适合对View内容的滑动</li>
<li>动画：操作简单，主要使用于没有交互的View以及复杂的动画效果</li>
<li>改变布局参数：操作稍微复杂，适用于有交互的View</li>
</ul>
<h2 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h2><h3 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h3><p>在介绍点击事件的传递规则前，首先我们要明白这里要分析的对象是MotionEvent，即点击事件。所谓点击事件的分发，其实就是对MotionEvent事件的分发过程，即当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递过程就是分发过程。点击事件的分发由三个很重要的方法来共同完成:dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。</p>
<ul>
<li>dispatchTouchEvent:用来进行事件分发。如果事件能够到达当前View，那么此方法一定会被调用，返回结果受当前View以及下级的dispatchTouchEvent方法的影响，表示是否消耗当前事件。</li>
<li>onInterceptTouchEvent:在dispatchTouchEvent方法中调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截此事件。</li>
<li>onTouchEvent:在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在用一个事件序列，当前事件无法再次接收到事件。</li>
</ul>
<p>三个方法之间的关系用伪代码表示如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent e)&#123;</span><br><span class="line">    boolean consume = false;</span><br><span class="line">    if(onInterceptTouchEvent(e))&#123;</span><br><span class="line">        consume = onTouchEvent(e);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return consume;</span><br></pre></td></tr></table></figure></p>
<h4 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h4><p>对于根ViewGroup来说，点击事件产生后，首先会传递给它，这时它的dispatchTouchEvent就会被调用，如果这个ViewGroup的onInteceptTouchEvent返回true就表示它要拦截当前事件，接着这个事件就会这个ViewGroup来处理，即它的的onTouchEvent方法就会被调用；如果这个onInterceptTouchEvent方法返回false，就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的dispacthTouchEvent方法就会被调用，如此反复直到事件被最终处理为止。</p>
<p>当一个View处理事件时，如果它设置了OnTouchListener，那么OnTouchListenr中的onTouch方法就会被调用。这时事件如何处理还要看onTouch的返回值，如果返回false，则当前View的onTouchEvent方法会被调用；如果返回true，那么onTouchEvent方法将不会被调用。由此可见，给View设置的onTouchListener，其优先级比onTouchEvent要高。在onTouchEvent方法中，如果当前方法有设置OnClickListener，那么它的onClick方法将被调用。可以看出，平时我们常用的OnClickListener，其优先级最低，即处于事件传递的尾端。</p>
<p>当一个事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View，即事件总是先传递给Activity，Activity在传给Window，最后Window再传递给View。顶级View接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个View的OnTouchEvent返回false，那么它的父容器的onTouchEvent将被调用，依次类推。如果所有的元素都不处理这个事件，那么这个事件最终将会交给Activity来处理，即Activity的onTouchEvent方法将会被调用。这个过程其实很好理解，我们换一种思路，加入点击事件是一个难题，这个难题被上级领导分配给了一个程序员去处理（这是事件分发过程），结果这个程序员搞不定（onTouchEvent方法返回了false），现在该怎么办呢？难题必须要解决，那只能交由水平更高的上级去解决（上级的onTouchEvent被调用），如果上级再搞不定，那只能交由上级的上级去解决，就这样将难题一层层的往上抛，这是公司内部一种很常见的处理问题的机制。从这个角度来看，View的事件传递还是还贴近现实的，毕竟程序员也生活在现实生活中。</p>
<p>关于事件传递的机制，这里给出一些结论，根据这些结论可以更好的理解整个传递机制：</p>
<ul>
<li>同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程所产生的一系列的事件，这个事件序列以down开始，中间含有数量不定的move事件，最终以up事件结束。</li>
<li>正常情况下，一个事件序列只能被一个View拦截且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了此事件，那么同一个事件序列的所有事件都会直接交由它处理，因此同一个事件序列中的事件不能同时由两个View处理，但是通过特殊的手段可以做到，比如一个View将本该自己处理的事件通过onTouchEvent强行传递给其它的View处理。</li>
<li>某个View一旦决定开始拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的onInteceptTouchEvent不会再被调用。这条也很好理解，就是说当一个View决定拦截一个事件后，那么系统会把同一个事件序列内的方法都直接交由它来处理，因此就不用再调用这个View的onInterceptTouchEvent去询问它是否要拦截了。</li>
<li>某个View事件一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么同一事件序列中的其它事件都不会交给他处理，并且事件将重新交给他的父元素去处理，即父元素的onTouchEvent会被调用。意思就是一个事件一旦交给一个View处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不在交给它处理了，这就好比上级交给程序员一件事，如果这件事没有处理好，短期内这个上级就不敢把事件交给这个程序员做了，二者是类似的道理。</li>
<li>如果View不消耗除了ACTION_DOWN以外的其它点击事件，那么这个点击事件就会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</li>
<li>ViewGroup默认不拦截任何事件。Android源码中ViewGroup的onInterceptTouchEvent方法默认返回false。</li>
<li>View没有onInterceptTouchEvent方法，一旦有点击事件传递给它，那么它的onTouchEvent方法就会被调用。</li>
<li>View的onTouchEvent默认都会消耗事件（即返回true）,除非它是不可点击的（clickable和longClickable为false)。View的longClickable默认为false，clickable要分情况，比如Button的clickable属性默认为true，而TextView的clickable属性默认为false。</li>
<li>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个View是disable状态的，只要它的clickable或者longClickable为true，那么它的onTouchEvent就返回true。</li>
<li>onClick能发生的前提是View是可点击的，并且它受到了down与up的事件。</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再有父元素分发给子View，通过requestDisallowInteceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</li>
</ul>
<h2 id="滑动冲突"><a href="#滑动冲突" class="headerlink" title="滑动冲突"></a>滑动冲突</h2><p>相信开发Android的都会有这种体会：滑动冲突太坑人了，本来网上下载好的demo好好的，但是只要出现滑动冲突，demo就无法正常工作了。那么滑动冲突时如何产生的呢？其实在界面中，只要内外两层可以同时滑动，这个时候就会产生滑动冲突。如何解决滑动冲突呢？这既是一件困难的事又是一件简单的事，说困难是因为很多开发者面对滑动冲突都会显得束手无策，说简单是因为滑动冲突的解决有固定的套路，只要知道了这个套路问题就好解决了。</p>
<h3 id="常见的滑动冲突场景"><a href="#常见的滑动冲突场景" class="headerlink" title="常见的滑动冲突场景"></a>常见的滑动冲突场景</h3><p>常见的滑动冲突可以分为以下三种：</p>
<ul>
<li>场景1——外部滑动方向与内部滑动方向不一致</li>
<li>场景2——外部滑动方向与内部滑动方向一致</li>
<li>上面两种情况的嵌套</li>
</ul>
<p>先说场景1，主要是将ViewPager与Fragment配合使用所组成的页面滑动效果，主流应用几乎都会使用这个效果。在这种效果中，可以通过左右滑动来切换页面，而每个页面内部又嵌套了一个ListView。本来这种情况是有滑动冲突的，但是ViewPager内部处理了这个滑动冲突，因此采用ViewPager时我们无须关注此问题。如果我们采用的不是ViewPager而是ScrollView等，那就必须手动处理滑动冲突了，否则造成的后果就是内外两层只有一层能进行滑动，这是因为两者之间的滑动事件有冲突。除了这种典型情况外，还存在其它的情况，比如外部上下滑动，内部左右滑动等，但是它们属于同一类滑动冲突。</p>
<p>再说场景2，这种情况稍微复杂些，当内外两层都在同一个方向可以进行滑动时，显然存在逻辑问题。因为当手指开始滑动时，系统无法知道用户到底是想让哪一层滑动，所以当手指滑动的时候就会出现问题，要么只有一层滑动，要么就是两层都滑动但是很卡顿。在实际开发中，这种场景主要是指内外两层同时上下滑动或者内外层同时左右滑动。</p>
<p>最后说下场景3，其实就是上面两种情况的嵌套，因此场景3的滑动冲突看起来就更复杂了。虽然说场景3滑动冲突看起来很复杂，但是它是几个单一滑动冲突的叠加，因此只需要处理内层和中层、中层与外层之间的滑动冲突即可，而具体的处理方法其实是和场景1、场景2相同的。</p>
<p>从本质上讲，这三种滑动冲突场景的复杂度其实是相同的，因为它们的区别仅仅是滑动策略的不同，至于解决滑动冲突的方法，它们几个是通用的，以下篇幅会做相应的介绍。</p>
<h3 id="滑动冲突的处理规则"><a href="#滑动冲突的处理规则" class="headerlink" title="滑动冲突的处理规则"></a>滑动冲突的处理规则</h3><p>一般来说，不管滑动冲突多么复杂，它都有既定的规则，根据这些规则我们可以选择合适的方法去处理。</p>
<p>对于场景1，它的处理规则是：当用户左右滑动时，需要让外部的View拦截点击事件，当用户上下滑动时，需要让内部的View拦截点击事件。这个时候我们就可以根据它的特征来解决滑动冲突，具体来说是：根据滑动是水平滑动还是竖直滑动来判断到底是谁来拦截事件。根据滑动过程中两个点之间的坐标就可以得出到底是水平还是竖直滑动。简单来说，可以有很多的参考，依据滑动路径与水平方向上的夹角，也可以一句水平方向与竖直方向的距离差来判定，某些特殊时候还可以依据水平与竖直方向的速度差来判断。选用规则可以结合具体场景来选择。</p>
<p>对于场景2，比较特殊，无法根据角度、距离差以及速度差来判断，但是这个时候一般都能在业务上找到突破点，比如业务上规定：当处于某种状态时需要外部View响应用户的滑动，而处于另外一种状态时需要内部View来响应View的滑动，根据这种业务需求我们也能指定出相应的处理规则，有了处理规则同样可以进行下一步的处理。</p>
<p>对于场景3，它的滑动规则更复杂了，和场景2一样，它也无法根据角度、距离差以及速度差来判断，同样还是只能从业务上找突破点，具体方法和场景2一样，都是从业务的需求得出对应的处理规则。</p>
<h3 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h3><p>首先我们分析滑动场景，这也是最简单、最典型的滑动冲突，因为它的滑动规则比较简单，不过多复杂的滑动冲突，它们之间的区别仅仅是滑动规则不同而已。抛开滑动规则不说，我们需要找到一种不依赖具体滑动的滑动规则的通用的解决方法，在这里我们需要根据场景1得出通用的解决方案，然后场景2、3只需要修改有关滑动规则的逻辑即可。</p>
<h4 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h4><p>所谓外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就进行拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突问题，这种方法比较符合事件的分发机制。外部拦截法需要重写父容器的onteceptTouchEvent方法，在内部做相应的拦截即可，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent event)&#123;</span><br><span class="line">    boolean intecepted = false;</span><br><span class="line">    int x = event.getX();</span><br><span class="line">    int y = event.getY();</span><br><span class="line">    switch(event.getAction())&#123;</span><br><span class="line">       case MotionEvent.ACTION_DOWN:</span><br><span class="line">          inteceped = false;</span><br><span class="line">          break;</span><br><span class="line">       case MotionEvent.ACTION_MOVE：</span><br><span class="line">          if(&quot;父容器需要拦截此事件&quot;）</span><br><span class="line">            intecepted =true;</span><br><span class="line">          else</span><br><span class="line">            intecepted = false;</span><br><span class="line">          break;</span><br><span class="line">       case MotionEvent.ACTION_UP:</span><br><span class="line">          intecepted = false;</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">         break;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return intecepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码是外部拦截法的典型逻辑，针对不同的滑动冲突，只需要修改父容器需要当前点击事件这个条件即可，其它均不需做修改并且也不能修改。这里对上述代码在描述一下，在onInteceptTouchEvent方法中，首先是ACTION_DOWN事件，父容器必须返回false，即不拦截此事件，这是因为一旦父容器拦截了此事件，后续的事件都会直接交由父容器处理，这个时候事件就没办法再传递给子元素了；其次是ACTION_MOVE事件，这个事件可以根据需要来决定是否需要拦截，如果父容器需要拦截就返回true，否则返回false；最后是ACTIO_UP事件，这里必须返回false，因为ACTION_UP事件本身没有太多意义。</p>
<p>考虑一种情况，假设事件交由子元素处理，如果父容器再ACTION_UP时返回了true，就会导致子元素无法接收到ACTION_UP事件，这个时候子元素的onClick方法就无法触发，但是父容器比较特殊，一旦它开始拦截任何一个事件，那么后续的事件都会交由它处理，而ACTION_UP作为最后一个事件也必定可以传递给父容器，即便父容器的onInteceptTouchEvent方法方法在ACTION_UP中返回了false。</p>
<h4 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h4><p>内部拦截法是指父容器不拦截任何事件，所有的事件都交由子元素，如果子元素需要此事件就消耗掉，否则就交由父容器处理，这种  方法和Android中的事件分发不一致，需要配合requestDisallowInteceptTouchEvent方法才能正常工作，使用起来较外部拦截法稍显复杂。伪代码如下,我们需要重写dispatchTouchEvent方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent event)&#123;</span><br><span class="line">    int x = event.getX();</span><br><span class="line">    int y = event.getY();</span><br><span class="line">    switch(event.getAction())&#123;</span><br><span class="line">       case MotionEvent.ACTION_DOWN:</span><br><span class="line">          parent.requestDisallowInteceptTouchEvent(true);</span><br><span class="line">          break;</span><br><span class="line">       case MotionEvent.ACTION_MOVE：</span><br><span class="line">          if(&quot;父容器需要此类点击事件&quot;)</span><br><span class="line">            parent.requestDisallowInteceptTouchEvent(false);</span><br><span class="line">          break;</span><br><span class="line">       case MotionEvent.ACTION_UP:</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">         break;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码是内部拦截法的典型代码，当面对不同的滑动策略时只需要修改里面的条件即可，其它不需要改动而且也不能改动。除了子元素需要做特殊处理外，父元素也要默认拦截除了ACTION_DOWN以外的其它事件，这样当子元素调用parent.requestDisallowInteceptTouchEvent(false)时，父元素才能继续拦截所需的事件。</p>
<p>为什么父容器不能拦截ACTION_DOWN事件呢？那是因为ACTION_DOWN事件并不受FLAG_DISALLOW_INTERCEPT这个标记位控制，所以一旦父容器拦截ACTION_DOWN事件，那么所有的事件都无法传到子元素中了，这样内部拦截就不起作用了。父元素所作修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent(MotionEvent event)&#123;</span><br><span class="line">     int action = event.getAction();</span><br><span class="line">     if(action == MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="滑动冲突总结"><a href="#滑动冲突总结" class="headerlink" title="滑动冲突总结"></a>滑动冲突总结</h4><p>所以对于滑动冲突，内部拦截法与外部拦截法都适用，当面对不同的滑动策略时只需要修改里面的条件即可，外部拦截法相对内部拦截法来说更简单更容易理解，可以优先考虑使用。</p>
<p>参考书籍: 《Android开发艺术探索》   </p>
</div><div class="tags"><a href="/tags/View滑动/">View滑动</a><a href="/tags/事件分发/">事件分发</a><a href="/tags/滑动冲突/">滑动冲突</a></div><div class="post-nav"><a class="pre" href="/2018/08/20/java_project/">记录建站遇到的各种问题</a><a class="next" href="/2018/08/18/iOS Runtime机制/">iOS Runtime机制</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://xybank.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/余声赞/">余声赞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/余硕/">余硕</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/匡利金/">匡利金</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/卓平/">卓平</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/卢文才/">卢文才</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/张杨/">张杨</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/张永枫/">张永枫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/彭连/">彭连</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/方振养/">方振养</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/李关浩/">李关浩</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/李志丹/">李志丹</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杨新才/">杨新才</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/洪宇杰/">洪宇杰</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/甘明阳/">甘明阳</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/甘潇敏/">甘潇敏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/童长钱/">童长钱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/蔡向炜/">蔡向炜</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/薛玉博/">薛玉博</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/赖钧/">赖钧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/陈志奇/">陈志奇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高兰花/">高兰花</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/黄涛/">黄涛</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rxjava/" style="font-size: 15px;">rxjava</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Rss/" style="font-size: 15px;">Rss</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/hibernate/" style="font-size: 15px;">hibernate</a> <a href="/tags/软考/" style="font-size: 15px;">软考</a> <a href="/tags/备考/" style="font-size: 15px;">备考</a> <a href="/tags/JavaScript，closure/" style="font-size: 15px;">JavaScript，closure</a> <a href="/tags/js，定时器/" style="font-size: 15px;">js，定时器</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/阿里云/" style="font-size: 15px;">阿里云</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Activity/" style="font-size: 15px;">Activity</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/file/" style="font-size: 15px;">file</a> <a href="/tags/Android-P/" style="font-size: 15px;">Android P</a> <a href="/tags/兼容适配/" style="font-size: 15px;">兼容适配</a> <a href="/tags/可读性/" style="font-size: 15px;">可读性</a> <a href="/tags/代码/" style="font-size: 15px;">代码</a> <a href="/tags/Bitmap/" style="font-size: 15px;">Bitmap</a> <a href="/tags/WeChat/" style="font-size: 15px;">WeChat</a> <a href="/tags/DingDing/" style="font-size: 15px;">DingDing</a> <a href="/tags/deviceId/" style="font-size: 15px;">deviceId</a> <a href="/tags/SharePreference/" style="font-size: 15px;">SharePreference</a> <a href="/tags/File/" style="font-size: 15px;">File</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/IPC/" style="font-size: 15px;">IPC</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/设计架构/" style="font-size: 15px;">设计架构</a> <a href="/tags/Fiddler/" style="font-size: 15px;">Fiddler</a> <a href="/tags/retrofit/" style="font-size: 15px;">retrofit</a> <a href="/tags/okhttp/" style="font-size: 15px;">okhttp</a> <a href="/tags/rxjava2/" style="font-size: 15px;">rxjava2</a> <a href="/tags/响应函数式/" style="font-size: 15px;">响应函数式</a> <a href="/tags/背压/" style="font-size: 15px;">背压</a> <a href="/tags/Serializable/" style="font-size: 15px;">Serializable</a> <a href="/tags/Parcelable/" style="font-size: 15px;">Parcelable</a> <a href="/tags/View滑动/" style="font-size: 15px;">View滑动</a> <a href="/tags/事件分发/" style="font-size: 15px;">事件分发</a> <a href="/tags/滑动冲突/" style="font-size: 15px;">滑动冲突</a> <a href="/tags/过度绘制/" style="font-size: 15px;">过度绘制</a> <a href="/tags/bootstrap/" style="font-size: 15px;">bootstrap</a> <a href="/tags/css，布局/" style="font-size: 15px;">css，布局</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/css3，flexbox/" style="font-size: 15px;">css3，flexbox</a> <a href="/tags/CSS的字体适配/" style="font-size: 15px;">CSS的字体适配</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/ewp中模拟报文的使用/" style="font-size: 15px;">ewp中模拟报文的使用</a> <a href="/tags/form表单，html5/" style="font-size: 15px;">form表单，html5</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/java，集合/" style="font-size: 15px;">java，集合</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/js，with/" style="font-size: 15px;">js，with</a> <a href="/tags/xhtml-lua/" style="font-size: 15px;">xhtml+lua</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/vi的编辑/" style="font-size: 15px;">vi的编辑</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/app/" style="font-size: 15px;">app</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/photoshop/" style="font-size: 15px;">photoshop</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/radio/" style="font-size: 15px;">radio</a> <a href="/tags/checked/" style="font-size: 15px;">checked</a> <a href="/tags/xq/" style="font-size: 15px;">xq</a> <a href="/tags/3种定位的使用/" style="font-size: 15px;">3种定位的使用</a> <a href="/tags/js中两种定时器的设置及清除/" style="font-size: 15px;">js中两种定时器的设置及清除</a> <a href="/tags/yaws/" style="font-size: 15px;">yaws</a> <a href="/tags/web/" style="font-size: 15px;">web</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/hibernate_hql/">hibernate里的HQL使用详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/iOS内存管理(补充)/">iOS内存管理补充</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/mysql_cmd/">mysql基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/blog_view_overdraw/">View的过度绘制简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/ITPMP/">信息系统项目管理师</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Hibernate_sum/">hibernate框架配置详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/radio_sum/">使用jquery做图形单选框</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/java_project/">记录建站遇到的各种问题</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/18/blog_view_distribute/">View的事件体系简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/18/iOS Runtime机制/">iOS Runtime机制</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">融易通兴业团队.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>