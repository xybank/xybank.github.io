<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS GCD | 融易通兴业团队</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS GCD</h1><a id="logo" href="/.">融易通兴业团队</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS GCD</h1><div class="post-meta">Sep 28, 2018<span> | </span><span class="category"><a href="/categories/卓平/">卓平</a></span></div><div class="post-content"><p>本文主要参考了《Objective-C 高级编程》中的GCD一章的内容。</p>
<h2 id="1-GCD-概要"><a href="#1-GCD-概要" class="headerlink" title="1. GCD 概要"></a>1. GCD 概要</h2><h3 id="1-1-什么是GCD"><a href="#1-1-什么是GCD" class="headerlink" title="1.1 什么是GCD"></a>1.1 什么是GCD</h3><blockquote>
<p>Grand Central Dispath(GCD)是异步执行的技术之一。一般将应用程序中记述的线程管理用的代码在<strong>系统级</strong>中实现。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率。————苹果官方说明</p>
</blockquote>
<p>GCD简洁明了，实现了极为复杂繁琐的多线程编程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_asyn(queue, ^&#123;</span><br><span class="line">	/* </span><br><span class="line">	 * 长时间处理</span><br><span class="line">	 * 如数据库访问等</span><br><span class="line">	 */</span><br><span class="line">	 </span><br><span class="line">	 /*</span><br><span class="line">	  * 长时间处理结束，主线程使用该处理结果</span><br><span class="line">	  */</span><br><span class="line">	  dispatch_async(dispatch_get_main_queue(),^&#123;</span><br><span class="line">	  		/*</span><br><span class="line">	  		 * 只在主线程可执行的处理</span><br><span class="line">	  		 * 例如用户界面更新</span><br><span class="line">	  		 */</span><br><span class="line">	  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在导入GCD之前，Cocoa框架提供了NSObject类的performSelectorBackgound:withObject实例方法和performSelectorOnMainThread实例方法等简单的多线程编程技术。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//NSObject performSelectorInBackgound:withObject:方法中执行后台线程</span><br><span class="line">- (void)launchThreadByNSObject_performSelectorInBackground_withobject &#123;</span><br><span class="line">	[self performSelectorInBackgound:@selector(doWork) withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后台线程处理方法</span><br><span class="line">- (void)doWork &#123;</span><br><span class="line">	NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];</span><br><span class="line">	/* </span><br><span class="line">	 * 长时间处理</span><br><span class="line">	 * 如数据库访问等</span><br><span class="line">	 */</span><br><span class="line">	 </span><br><span class="line">	 /*</span><br><span class="line">	  * 长时间处理结束，主线程使用该处理结果</span><br><span class="line">	  */</span><br><span class="line">	 [self performSelectorOnMainThread:@selector(doneWork) withObject:nil waitUntilDone:NO];</span><br><span class="line">	 [pool drain];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//主线程处理方法</span><br><span class="line">- (void)doneWork &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>performSelector系方法确实比使用NSThread类进行多线程编程要简单，但是与GCD先比，结果一目了然，且通过GCD提供的系统级线程管理可提高执行效率。</p>
<h3 id="1-2-多线程编程"><a href="#1-2-多线程编程" class="headerlink" title="1.2 多线程编程"></a>1.2 多线程编程</h3><p>源码通过编译器转换为CPU命令（二进制代码），应用启动后首先将包含在程序中的CPU命令配置到内存中。CPU从应用程序指定的地址开始，一个一个的执行命令列。由于一个CPU一次只能执行一个命令列，不能执行某处分开的并列的两个命令，因此通过CPU执行的CPU命令就好比一条无分叉的路径，其执行不会出现分歧。</p>
<p>这里说到的“一条无分叉的路径”即为线程。尽管有多核CPU，但是一个CPU一次只能执行一个命令列为一条无分叉的路径仍然不变。</p>
<p>无分叉的路径不止1条，存在有多条即为“多线程”。在多线程中，一个CPU执行多条不同路径上不同命令。</p>
<p><strong>1个CPU核一次能够执行的CPU命令始终为1。那么如何才能在多条路径中执行CPU命令列呢？</strong></p>
<p>在OS X和iOS的核心XNU内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器等信息保存到各自专用的内存块中，从切换目标路径专用的内存中复原CPU寄存器等信息，继续执行切换路径的CPU命令列。这被称为“上下文切换”。</p>
<p>由于使用多线程的程序可以在某个线程和其他线程之间反复多次进行切换上下文，且速度极快。看上去就好像1个CPU核能够并列地执行多个程序一样。这称之为——“并发”。在多个CPU的情况下就不是看上去像了，而是真的提供多个CPU核并行的执行多个线程。</p>
<p>这种利用多线程编程的技术就被称为“多线程编程”。</p>
<p>多线程编程实际是一个容易发生各种问题的编程技术。比如资源竞争、死锁、使用太多线程会消耗大量内存等。</p>
<p>要回避这些问题有许多方法，但程序都会更加复杂。尽管极易发生问题，也应该多使用多线程编程。因为使用多线程编程可保证应用程序的响应性能。</p>
<h2 id="2-GCD的API"><a href="#2-GCD的API" class="headerlink" title="2. GCD的API"></a>2. GCD的API</h2><h3 id="2-1-Dispatch-Queue"><a href="#2-1-Dispatch-Queue" class="headerlink" title="2.1 Dispatch Queue"></a>2.1 Dispatch Queue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">	//想执行的任务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue中。<br>代码中使用Block语法来定义想要执行的任务，并通过dispatch_async函数追加到赋值变量queue中。</p>
<p>Dispatch_queue是执行处理的队列，队列按照先进先出的原则执行处理添加到队列中的任务。</p>
<p>队列分两种，一种是等待现在执行中处理的串行队列(DISPATCH_QUEUE_SERIAL)，另一种是不等待现在执行处理的并发队列(DISPATCH_QUEUE_CONCURRENT)。</p>
<p>比较这两种队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//串行队列</span><br><span class="line">dispatch_async(queue, blk0);</span><br><span class="line">dispatch_async(queue, blk1);</span><br><span class="line">dispatch_async(queue, blk2);</span><br><span class="line">dispatch_async(queue, blk3);</span><br><span class="line">dispatch_async(queue, blk4);</span><br><span class="line">dispatch_async(queue, blk5);</span><br><span class="line">dispatch_async(queue, blk6);</span><br><span class="line"></span><br><span class="line">//串行队列输出</span><br><span class="line">blk0</span><br><span class="line">blk1</span><br><span class="line">blk2</span><br><span class="line">blk3</span><br><span class="line">blk4</span><br><span class="line">blk5</span><br><span class="line">blk6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//并发队列</span><br><span class="line">dispatch_async(queue, blk0);</span><br><span class="line">dispatch_async(queue, blk1);</span><br><span class="line">dispatch_async(queue, blk2);</span><br><span class="line">dispatch_async(queue, blk3);</span><br><span class="line">dispatch_async(queue, blk4);</span><br><span class="line">dispatch_async(queue, blk5);</span><br><span class="line">dispatch_async(queue, blk6);</span><br><span class="line"></span><br><span class="line">//并发队列输出，由于并发执行处理的数量取决于当前的系统的状态，所以输出的结果不是顺序的。</span><br><span class="line">blk1</span><br><span class="line">blk0</span><br><span class="line">blk2</span><br><span class="line">blk3</span><br><span class="line">blk6</span><br><span class="line">blk4</span><br><span class="line">blk5</span><br></pre></td></tr></table></figure>
<p>XNU内核决定应当使用的线程数，并只生成所需的线程执行处理，线程都由XNU内核来管理。Concurrent Dispatch Queue中执行处理时，执行顺序会根据处理内容和系统状态发生改变。它不同于执行顺序固定的Serial Dispatch Queue。在不能改变执行的处理顺序或不想并发执行多个处理时使用。</p>
<h3 id="2-2-dispatch-queue-create"><a href="#2-2-dispatch-queue-create" class="headerlink" title="2.2 dispatch_queue_create"></a>2.2 dispatch_queue_create</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*	queue.h中的声明</span><br><span class="line"> *	dispatch_queue_t</span><br><span class="line"> *	dispatch_queue_create(const char *_Nullable label,dispatch_queue_attr_t _Nullable attr);</span><br><span class="line"> */</span><br><span class="line">  </span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd.myqueue&quot;,NULL);</span><br></pre></td></tr></table></figure>
<p><strong>dispatch_queue_t</strong>：队列类型<br><strong>label</strong>：线程标识符，用于标记线程<br><strong>dispatch_queue_attr_t</strong>：队列的属性，NULL、DISPATCH_QUEUE_SERIAL、DISPATCH_QUEUE_CONCURRENT等，其中NULL与DISPATCH_QUEUE_SERIAL等价。</p>
<p>虽然Serial Dispatch Queue 和 Concurrent Dispatch Queue受到系统资源的限制，但用dispatch_queue_create可以创建任意多个Dispatch Queue。</p>
<p>当生成多个Serial Dispatch Queue是，各个Serial Dispatch Queue将并发执行。但是<strong>一旦生成Serial Dispatch Queue并追加处理，系统对于Serial Dispatch Queue就只生成并使用一个线程</strong>。如果创建2000个Serial Dispatch Queue就会有2000个线程生成。这样就会消耗大量的内存，引起大量的上下文切换，大幅度降低系统的响应性能。<br><strong>只在为了避免多线程编程问题之一——多个线程更新相同资源导致数据竞争时使用Serial Dispatch Queue。</strong></p>
<p>当想并发执行不发生数据竞争等问题的处理时，使用Concurrent Dispatch Queue。而且<strong>对于Concurrent Dispatch Queue来说，不管生成多少，由于XNU内核只使用有效管理的线程</strong>，因此不会发生Serial Dispatch Queue的问题。</p>
<p>从iOS6.0起，GCD对象就被纳入ARC的管理范畴，ARC程序中不再需要调用dispatch_release来释放GCD对象。</p>
<h3 id="2-3-Main-Dispatch-Queue-Global-Dispatch-Queue"><a href="#2-3-Main-Dispatch-Queue-Global-Dispatch-Queue" class="headerlink" title="2.3 Main Dispatch Queue/Global Dispatch Queue"></a>2.3 Main Dispatch Queue/Global Dispatch Queue</h3><p>系统为我们提供了Main Dispatch Queue和Global Dispatch Queue。</p>
<p><strong>Main Dispatch Queue：</strong></p>
<p>主线程中执行的Dispatch Queue。因为主线程只有一个，所以Main Dispatch Queue自然就是Serial Dispatch Queue。</p>
<p>追加到Main Dispatch Queue的处理在主线程RunLoop中执行。因此将将用户界面更新的一些必须放在主线程中执行的处理追加到Main Dispatch Queue使用。</p>
<p><strong>Global Dispatch Queue：</strong></p>
<p><strong>Global Dispatch Queue是所有应用程序都能够使用的Concurrent Dispatch Queue。</strong>没必要通过dispatch_queue_create函数逐个生成Concurrent Dispatch Queue。只需获取Global Dispatch Queue使用即可。</p>
<p>Global Dispatch Queue有4个执行优先级</p>
<ul>
<li>高优先级（Hight Priority）</li>
<li>默认优先级（Default Priority）</li>
<li>低优先级（Low Priority）</li>
<li>后台优先级（Background Priority）</li>
</ul>
<p>优先顺序从高到低，通过XUN内核管理的用于Global Dispatch Queue的线程，将各自使用的Global Dispatch Queue的执行优先级作为线程的执行优先级使用。</p>
<p>但是通过XUN内核用于Global Dispatch Queue的线程并不能保证实时性，因此执行优先级只是大致的判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Main Dispath Queue的获取方法</span><br><span class="line">dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();</span><br><span class="line"></span><br><span class="line">//Global Dispatch Queue(高优先级)的获取方法</span><br><span class="line">dispatch queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</span><br><span class="line"></span><br><span class="line">//Global Dispatch Queue(默认优先级)的获取方法</span><br><span class="line">dispatch queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">//Global Dispatch Queue(低先级)的获取方法</span><br><span class="line">dispatch queue_t globalDispatchQueueLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</span><br><span class="line"></span><br><span class="line">//Global Dispatch Queue(后台优先级)的获取方法</span><br><span class="line">dispatch queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br></pre></td></tr></table></figure>
<h3 id="2-4-dispatch-set-target-queue"><a href="#2-4-dispatch-set-target-queue" class="headerlink" title="2.4 dispatch_set_target_queue"></a>2.4 dispatch_set_target_queue</h3><p><strong>用途：变更生成的Dispatch Queue的执行优先级</strong></p>
<p><strong>PS：</strong>dispatch_queue_create函数生成的Dispatch Queue不管是Serial Dispatch Queue还是Concurrent Dispatch Queue,都是用与默认优先级Global Dispatch Queue相同执行优先级的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create(&quot;com.example.gcd.mySerialDispatchQueue&quot;,NULL);</span><br><span class="line"></span><br><span class="line">dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</span><br><span class="line"></span><br><span class="line">dispatch_set_target_queue(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure>
<p>dispatch_set_target_queue函数的第一个参数是要变更优先级的Dispatch Queue，第二个是指定要使用的执行优先级相同的目标Dispatch Queue。但是如果要变更的Dispatch Queue指定了系统提供的Main Dispatch Queue和Global Dispatch Queue则不知道会出现什么情况，因此这些均不可指定。</p>
<p><strong>用法：</strong>将Dispatch Queue指定为dispatch_set_target_queue的函数参数，不仅可以变更Dispatch Queue的执行优先级，还可以作为Dispatch Queue的执行阶层。如果在多个Serial Dispatch Queue中用dispatch_set_target_queue函数指定目标为某一个Serial Dispatch Queue，那么原本应该并发执行的多个Serial Dispatch Queue，在目标Serial Dispatch Queue上只能同时执行一个处理</p>
<h3 id="2-5-dispatch-after"><a href="#2-5-dispatch-after" class="headerlink" title="2.5 dispatch_after"></a>2.5 dispatch_after</h3><p><strong>用途：在指定时间追加处理到Dispatch Queue。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 3ull*NSEC_PER_SEC);</span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">	NSLog(@&quot;waited at least three seconds.&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定时间用的dispatch_time_t类型值中指定的时间开始，到第二个参数指定的毫微秒单位时间后的时间。</p>
<p>dispatch_after函数并不是在指定时间后执行处理，而只是在指定时间追加处理到Dispatch Queue。<br>因为Main Dispatch Queue在主线程的RunLoop中执行，所以在比如每隔1/60秒执行的RunLoop中，Block最快在3秒后执行，最慢在3秒+1/60秒后执行，并且Main Dispatch Queue有大量处理追加或主线程本身有延迟是，这个时间会更长。</p>
<h3 id="2-6-Dispatch-Group"><a href="#2-6-Dispatch-Group" class="headerlink" title="2.6 Dispatch Group"></a>2.6 Dispatch Group</h3><p><strong>用途：监听和等待Group中所有执行处理的情况。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk0&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(),^&#123;NSLog(@&quot;done&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">//执行结果</span><br><span class="line">/* blk1</span><br><span class="line"> * blk2</span><br><span class="line"> * blk0</span><br><span class="line"> * done</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>以上代码，追加处理的执行顺序不定。执行时会发生变化，但是done一定是在最后输出的。Dispatch_Goup监听这些处理执行结束，一旦检测到所有处理执行结束，就可将结束的处理追加到Dispatch Queue中。这就是使用Dispatch Gourp的原因。</p>
<p>另外，Dispatch Gourp中也可以使用dispatch_group_wait函数仅等待全部处理执行结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk0&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk1&quot;);&#125;);</span><br><span class="line">dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;blk2&quot;);&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p>函数的第二个参数表示等待时间，这里的DISPATCH_TIME_FOREVER意味着永久等待。只要Dispatch Group的处理尚未执行结束，就会一直等待，中途不能取消。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, 1ull * NSEC_PER_SEC);</span><br><span class="line">long result = dispatch_group_wait(group, time);</span><br><span class="line">if (result == 0) &#123;</span><br><span class="line">	//属于Dispatch Group的全部处理执行结束</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	//属于Dispatch Group的某个处理还在执行中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatch_group_wait函数的返回值不为0则表示经过了指定时间，但是属于Dispatch Group的某一个处理还在执行中。如果返回值为0则表示全部处理执行结束。</p>
<p>指定DISPATCH_TIME_FOREVER，则返回值必定为0。</p>
<p>指定DISPATCH_TIME_NOW，则不用任何等待即可判定属于Dispatch Group的处理是否结束。<br>在主线程的RunLoop的每次循环中，可检查执行是否结束，从而不耗费多余的等待时间。但是一般多使用dispatch_group_notify函数来实现，因为它更简洁明了。</p>
<h3 id="2-7-dispatch-barrier-async"><a href="#2-7-dispatch-barrier-async" class="headerlink" title="2.7 dispatch_barrier_async"></a>2.7 dispatch_barrier_async</h3><p><strong>用途：可以避免多线程数据竞争引发的问题。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_writing);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br></pre></td></tr></table></figure>
<p>以上代码由于追加处理的执行顺序是随机的，那么在读写操作时就会出现问题。</p>
<p>但是通过dispatch_barrier_async就能解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;,DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_barrier_async(queue, blk0_for_writing);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br><span class="line">dispatch_async(queue, blk0_for_reading);</span><br></pre></td></tr></table></figure>
<p>当程序执行到dispatch_barrier_async时，就会等到队列中的其他处理全部结束后，再它的处理追加到队列中。</p>
<h3 id="2-8-dispatch-sync"><a href="#2-8-dispatch-sync" class="headerlink" title="2.8 dispatch_sync"></a>2.8 dispatch_sync</h3><p>dispatch_sync，即是同步处理，意味着它会阻塞线程，直至执行的处理执行结束。可以说是简易版的dispatch_group_wait函数。</p>
<p>但是使用时要注意，可能会引起死锁的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">dispatch_sync(queue, ^&#123;NSLog(@&quot;Hello?&quot;);&#125;);</span><br></pre></td></tr></table></figure>
<p>由于主线程被阻塞，导致被追加的处理需要等待被阻塞的线程先执行完处理。然而主线程正是要执行这个处理，因此就会产生死锁。</p>
<p>在Serial Dispatch Queue中也会引起相同的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.gcd&quot;, NULL);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">	dispatch_sync(queue, ^&#123;NSLog(@&quot;hello?&quot;);&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="2-9-dispatch-apply"><a href="#2-9-dispatch-apply" class="headerlink" title="2.9 dispatch_apply"></a>2.9 dispatch_apply</h3><p><strong>用途：dispatch_apply函数是dispatch_sync函数和Dispatch Group的关联API。该函数按指定次数将指定Block追加到指定的Dispatch Queue中，并等待全部处理直接结束</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_apply(10, queue, ^&#123;size_t index&#125;) &#123;</span><br><span class="line">	NSLog(@&quot;%zu&quot;,index);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;done&quot;);</span><br><span class="line"></span><br><span class="line">//输出结果</span><br><span class="line">/*</span><br><span class="line"> * 4</span><br><span class="line"> * 1</span><br><span class="line"> * 0</span><br><span class="line"> * 2</span><br><span class="line"> * 3</span><br><span class="line"> * 5</span><br><span class="line"> * 6</span><br><span class="line"> * 7</span><br><span class="line"> * 8</span><br><span class="line"> * 9</span><br><span class="line"> * done</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>由于dispatch_apply函数会阻塞线程，因此推荐在dispatch_async函数中非同步地执行dispatch_apply函数。</p>
<h3 id="2-10-dispatch-suspend-dispatch-resume"><a href="#2-10-dispatch-suspend-dispatch-resume" class="headerlink" title="2.10 dispatch_suspend/dispatch_resume"></a>2.10 dispatch_suspend/dispatch_resume</h3><p><strong>用途：dispatch_suspend可将整个线程挂起，dispatch_resume将挂起的线程重新启动。执行函数对已执行的处理没有影响。挂起后尚未执行的处理停止执行。而恢复则使得这些处理能够继续执行。</strong></p>
<h3 id="2-11-dispatch-once"><a href="#2-11-dispatch-once" class="headerlink" title="2.11 dispatch_once"></a>2.11 dispatch_once</h3><p><strong>用途：保证应用程序执行中只执行一次指定处理。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//方法一</span><br><span class="line">static int initialized = NO;</span><br><span class="line">if (initialized == NO) &#123;</span><br><span class="line">	//初始化</span><br><span class="line">	initialized = YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方法二</span><br><span class="line">static dispatch_onece_t pred;</span><br><span class="line">dispatch_once(&amp;pred, ^&#123;</span><br><span class="line">	//初始化</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码看似能达到相同的效果，但是通过dispatch_once函数，方法二即使在多线程环境下执行，也可以保证百分之百安全。</p>
<h3 id="2-12-Dispatch-Semaphore"><a href="#2-12-Dispatch-Semaphore" class="headerlink" title="2.12 Dispatch Semaphore"></a>2.12 Dispatch Semaphore</h3><p><strong>用途：更细粒度的避免多线程带来的数据竞争问题。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc]init];</span><br><span class="line">for (int i=0; i&lt;100000; ++i) &#123;</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		[array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码异步更新了NSMutableArray类的对象，所以执行后有内存错误导致应用崩溃的概率很高，此时应该使用Dispatch Semaphore。</p>
<p>Dispatch Semaphore是持有计数的信号量，该计数是多线程编程中的计数类型信号量。计数为0时等待，计数为1或大于1时，减去1而不等待。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//初始化计数值为1的semaphore</span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">//dispatch_semaphore_wait等待信号量的计数值大于或等于1。该函数会减去1并返回计数值，当值为0时，该函数可以安全的进行排他处理。</span><br><span class="line">dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">//当排他处理结束时，就可以通过dispatch_semaphore_signal将计数值加1</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure>
<p>实际中的应用代码实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, O);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 生成Dispatch Semaphore</span><br><span class="line"> * Dispatch Semaphore的技术初始值设为1</span><br><span class="line"> * 保证可访问的NSMutableArray类对象的线程</span><br><span class="line"> * 同时只能有一个。</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">NSMutableArray *array = [[NSMutableArray alloc]init];</span><br><span class="line"></span><br><span class="line">for (int i=0; i&lt;100000; ++i) &#123;</span><br><span class="line">	dispatch_async(queue, ^&#123;</span><br><span class="line">		/*</span><br><span class="line">		 * 等待Dispatch Semaphore</span><br><span class="line">		 * </span><br><span class="line">		 * 一直等待，直到信号量大于或等于1</span><br><span class="line">		 */</span><br><span class="line">		dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">		</span><br><span class="line">		/*</span><br><span class="line">		 * 此时信号量为0</span><br><span class="line">		 * </span><br><span class="line">		 * 由于可以访问NSMutableArray类对象的线程</span><br><span class="line">		 * 只有一个，因此可以安全的更新。</span><br><span class="line">		 */</span><br><span class="line">		[array addObject:[NSNumber numberWithInt:i]];</span><br><span class="line">		</span><br><span class="line">		/*</span><br><span class="line">		 * 排他处理结束后，计数值加1</span><br><span class="line">		 */</span><br><span class="line">		dispatch_semaphore_signal(semaphore);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="tags"><a href="/tags/iOS/">iOS</a></div><div class="post-nav"><a class="pre" href="/2018/10/06/spring_start/">spring的基本使用</a><a class="next" href="/2018/09/18/hibernate_hql/">hibernate里的HQL使用详解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://xybank.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/余声赞/">余声赞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/余硕/">余硕</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/匡利金/">匡利金</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/卓平/">卓平</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/卢文才/">卢文才</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/张杨/">张杨</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/张永枫/">张永枫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/彭连/">彭连</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/方振养/">方振养</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/李关浩/">李关浩</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/李志丹/">李志丹</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杨新才/">杨新才</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/洪宇杰/">洪宇杰</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/甘明阳/">甘明阳</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/甘潇敏/">甘潇敏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/童长钱/">童长钱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/蔡向炜/">蔡向炜</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/薛玉博/">薛玉博</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/赖钧/">赖钧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/陈志奇/">陈志奇</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高兰花/">高兰花</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/黄涛/">黄涛</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/rxjava/" style="font-size: 15px;">rxjava</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Rss/" style="font-size: 15px;">Rss</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/hibernate/" style="font-size: 15px;">hibernate</a> <a href="/tags/软考/" style="font-size: 15px;">软考</a> <a href="/tags/备考/" style="font-size: 15px;">备考</a> <a href="/tags/JavaScript，closure/" style="font-size: 15px;">JavaScript，closure</a> <a href="/tags/js，定时器/" style="font-size: 15px;">js，定时器</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/阿里云/" style="font-size: 15px;">阿里云</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Activity/" style="font-size: 15px;">Activity</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/file/" style="font-size: 15px;">file</a> <a href="/tags/Android-P/" style="font-size: 15px;">Android P</a> <a href="/tags/兼容适配/" style="font-size: 15px;">兼容适配</a> <a href="/tags/可读性/" style="font-size: 15px;">可读性</a> <a href="/tags/代码/" style="font-size: 15px;">代码</a> <a href="/tags/Bitmap/" style="font-size: 15px;">Bitmap</a> <a href="/tags/WeChat/" style="font-size: 15px;">WeChat</a> <a href="/tags/DingDing/" style="font-size: 15px;">DingDing</a> <a href="/tags/deviceId/" style="font-size: 15px;">deviceId</a> <a href="/tags/SharePreference/" style="font-size: 15px;">SharePreference</a> <a href="/tags/File/" style="font-size: 15px;">File</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/IPC/" style="font-size: 15px;">IPC</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/设计架构/" style="font-size: 15px;">设计架构</a> <a href="/tags/Fiddler/" style="font-size: 15px;">Fiddler</a> <a href="/tags/retrofit/" style="font-size: 15px;">retrofit</a> <a href="/tags/okhttp/" style="font-size: 15px;">okhttp</a> <a href="/tags/rxjava2/" style="font-size: 15px;">rxjava2</a> <a href="/tags/响应函数式/" style="font-size: 15px;">响应函数式</a> <a href="/tags/背压/" style="font-size: 15px;">背压</a> <a href="/tags/Serializable/" style="font-size: 15px;">Serializable</a> <a href="/tags/Parcelable/" style="font-size: 15px;">Parcelable</a> <a href="/tags/View滑动/" style="font-size: 15px;">View滑动</a> <a href="/tags/事件分发/" style="font-size: 15px;">事件分发</a> <a href="/tags/滑动冲突/" style="font-size: 15px;">滑动冲突</a> <a href="/tags/过度绘制/" style="font-size: 15px;">过度绘制</a> <a href="/tags/bootstrap/" style="font-size: 15px;">bootstrap</a> <a href="/tags/css，布局/" style="font-size: 15px;">css，布局</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/css3，flexbox/" style="font-size: 15px;">css3，flexbox</a> <a href="/tags/CSS的字体适配/" style="font-size: 15px;">CSS的字体适配</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/ewp中模拟报文的使用/" style="font-size: 15px;">ewp中模拟报文的使用</a> <a href="/tags/form表单，html5/" style="font-size: 15px;">form表单，html5</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/java，集合/" style="font-size: 15px;">java，集合</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/js，with/" style="font-size: 15px;">js，with</a> <a href="/tags/xhtml-lua/" style="font-size: 15px;">xhtml+lua</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/vi的编辑/" style="font-size: 15px;">vi的编辑</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/app/" style="font-size: 15px;">app</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/photoshop/" style="font-size: 15px;">photoshop</a> <a href="/tags/html/" style="font-size: 15px;">html</a> <a href="/tags/radio/" style="font-size: 15px;">radio</a> <a href="/tags/checked/" style="font-size: 15px;">checked</a> <a href="/tags/xq/" style="font-size: 15px;">xq</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/3种定位的使用/" style="font-size: 15px;">3种定位的使用</a> <a href="/tags/js中两种定时器的设置及清除/" style="font-size: 15px;">js中两种定时器的设置及清除</a> <a href="/tags/yaws/" style="font-size: 15px;">yaws</a> <a href="/tags/web/" style="font-size: 15px;">web</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/10/06/spring_start/">spring的基本使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/28/iOS GCD/">iOS GCD</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/18/hibernate_hql/">hibernate里的HQL使用详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/mysql_cmd/">mysql基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/16/iOS内存管理(补充)/">iOS内存管理补充</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/blog_view_overdraw/">View的过度绘制简述</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/29/ITPMP/">信息系统项目管理师</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/28/Hibernate_sum/">hibernate框架配置详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/radio_sum/">使用jquery做图形单选框</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/20/java_project/">记录建站遇到的各种问题</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">融易通兴业团队.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>