<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Rxjava2学习总结 | 融易通兴业团队</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Rxjava2学习总结</h1><a id="logo" href="/.">融易通兴业团队</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Rxjava2学习总结</h1><div class="post-meta">Jul 18, 2018<span> | </span><span class="category"><a href="/categories/彭连/">彭连</a></span></div><div class="post-content"><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>对于Rxjava1与Rxjava2之前在项目中多少都使用过，由于Rxjava1与Rxjava2并无继承关系，后者在背压支持上更优秀且前者已经不再维护，所以着重介绍Rxjava2。</p>
<h3 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h3><p>函数响应式编程是函数式编程和响应式编程这两大颠覆传统的牛逼编程范式叠加后的产物，编程界的牛逼二次方。</p>
<h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>是一种通过函数或者函数组合调用来处理数据，获取结果的编程范式。</p>
<h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p>是一种面向数据流以及变化传播的一种范式，其中变化传播在程序中也是转换为数据流的形式进行处理。</p>
<h4 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h4><p>是一种通过一系列的函数组合调用来发射、转变以及监听，响应数据流的编程范式。在RxJava中，函数响应式编程具体表现为一个观察者（Observer）订阅一个可观察对象（Observable），通过创建可观察对象发射数据流，经过一系列操作符（Operators）加工处理和线程调度器（Scheduler）在不同线程间的转发，最后由观察者接受并做出响应的一个过程。</p>
<p>在RxJava2中，提供了五对观察者模式组合来完成这一系列的过程，每一对组合依靠其可调用的一系列函数的差异，而具有各自的特点。这五类组合（前为可观察对象后为对应的观察者）分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一组：ObservableSource/Observer</span><br><span class="line">一次可发送单条数据或者数据序列onNext，可发送完成通知onComplete或异常通知onError，不支持背压。</span><br><span class="line"></span><br><span class="line">第二组：Publisher/Subscriber</span><br><span class="line">第一组基础上进行改进，支持背压，一次可发送单条数据或者数据序列onNext，可发送完成通知onComplete或异常通知onError，但效率没有第一组高。</span><br><span class="line"></span><br><span class="line">第三组：SingleSource/SingleObserver</span><br><span class="line">第一组简化版，只能发送单条数据onSuccess，或者异常通知onError</span><br><span class="line"></span><br><span class="line">第四组：CompletableSource/CompletableObserve</span><br><span class="line">第一组简化版，不能发送数据，只发送完成通知onComplete或者异常通知onError</span><br><span class="line"></span><br><span class="line">第五组：MaybeSource/MaybeObserver</span><br><span class="line">第三，第四组的合并版，只能发送单条数据onSuccess和完成通知onComplete或者发送一条异常通知onError</span><br></pre></td></tr></table></figure>
<h2 id="Rxjava2使用介绍"><a href="#Rxjava2使用介绍" class="headerlink" title="Rxjava2使用介绍"></a>Rxjava2使用介绍</h2><p>先来一波代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//被观察者</span><br><span class="line">        Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123;</span><br><span class="line">                e.onNext(&quot;hello world&quot;)  //执行observer的onNext()回调方法</span><br><span class="line">                e.onNext(&quot;hello world&quot;);</span><br><span class="line">                e.onComplete();//执行onComplete()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //观察者</span><br><span class="line">        Observer observer = new Observer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Disposable d) &#123;</span><br><span class="line">              //Disposable是观察者Observer与可观察对象Observable建立订阅关系后生成的用来取消订阅关系和判断订阅关系是否存在的一个接口。</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(String o) &#123;</span><br><span class="line">                //默认执行的方法,无调用限制</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">              //发送异常通知，只会执行一次与onComplete互斥,不在执行后面的操作</span><br><span class="line">            &#125;</span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">              //发送完成通知，只会执行一次与onError互斥,不在执行后面的操作</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        //绑定形成订阅关系</span><br><span class="line">        observable.subscribe(observer);</span><br></pre></td></tr></table></figure></p>
<p>rxjava2与rxjava1一样都是基于观察者模式，所以会包含观察者与被观察者，被观察者（Observable/Flowable）通过发送事件告知（订阅的关系）观察者然后观察者进行消费操作，这就是最简单的一个流程。</p>
<p>以上注释都很清楚，就不多说了，需要说明的一点是如果调用Disposable的dispose()方法解除绑定，对于被观察者发送事件是没影响的，只不过Observer是不会再消费后面的事件了。</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>操作符（Operators）：其实质是函数式编程中的高阶函数，是对响应式编程的各个过程拆分封装后的产物，以便于我们操作数据流。</p>
<p>操作符大致可以分为一下几个类别，以下将对常用的几个操作符作介绍:</p>
<h4 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Observable，可接受一个或多个参数，将每个参数逐一发送</span><br><span class="line">        Observable.just(&quot;hello world&quot;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) throws Exception &#123;</span><br><span class="line">                System.out.println(s);  //打印hello world</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //fromArray:创建一个Observable，接受一个数组，并将数组中的数据逐一发送</span><br><span class="line">        //fromIterable：&lt;/b&gt;创建一个Observable，接受一个可迭代对象，并将可迭代对象中的数据逐一发送</span><br><span class="line">        //range：&lt;/b&gt;创建一个Observable，发送一个范围内的整数序列</span><br><span class="line">        //Observable.range(1,10);//从1开始以步长1递增发送10个数据</span><br><span class="line">        Observable.range(0,5).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                System.out.println(integer); //依次打印0-5</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="过滤操作符"><a href="#过滤操作符" class="headerlink" title="过滤操作符"></a>过滤操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//filter：filter使用Predicate 函数接口传入条件值，来判断Observable发射的每一个值是否满足这个条件，如果满足，则继续向下传递，如果不满足，则过滤掉。</span><br><span class="line">       Observable.range(0,10).filter(new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public boolean test(Integer integer) throws Exception &#123;</span><br><span class="line">               return integer % 3 == 0;  //判断条件  为true则传递给Observer</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">               System.out.println(integer);  //打印0，3，6，9</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       //distinct:过滤掉重复的数据项，过滤规则为：只允许还没有发射过的数据项通过。</span><br><span class="line">       Observable.just(1,1,1,2,3,3,4,4,5).distinct().subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">               System.out.println(integer);  //打印1，2，3，4，5</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       //当然也可以将filter与distinct进行组合链式使用</span><br><span class="line">       Observable.just(1,1,1,2,3,3,4,4,5,6).distinct().filter(new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public boolean test(Integer integer) throws Exception &#123;</span><br><span class="line">               return integer % 3 == 0;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">               System.out.println(integer);  //3，6</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//map:对Observable发射的每一项数据应用一个函数，执行变换操作</span><br><span class="line">       //map操作符，需要接收一个函数接口Function&lt;T,R&gt;的实例化对象，实现接口内R apply(T t)的方法，在此方法中可以对接收到的数据t进行变换后返回。</span><br><span class="line">      Observable.range(0,5).map(new Function&lt;Integer, String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public String apply(Integer integer) throws Exception &#123;</span><br><span class="line">              return &quot;item:&quot;+integer * integer;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void accept(String s) throws Exception &#123;</span><br><span class="line">              System.out.println(s); //打印item:0，item:1，item:4，item:9，item:16，item:25</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      //flatMap:将一个发射数据的Observable变换为多个Observable，然后将多个Observable发射的数据合并到一个Observable中进行发射</span><br><span class="line">       Integer[] num1 = new Integer[]&#123;1,2,3,4&#125;;</span><br><span class="line">       Integer[] num2 = new Integer[]&#123;5,6&#125;;</span><br><span class="line">       Integer[] num3 = new Integer[]&#123;7,8,9&#125;;</span><br><span class="line">       Observable.just(num1, num2, num3).flatMap(new Function&lt;Integer[], Observable&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Observable&lt;Integer&gt; apply(Integer[] integers) throws Exception &#123;</span><br><span class="line">               return Observable.fromArray(integers);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">               System.out.println(integer); //依次打印1-9</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//mergeWith：合并多个Observable发射的数据，可能会让Observable发射的数据交错。</span><br><span class="line">       Integer []num4 = new Integer[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">       Observable.just(5,6,7,8).mergeWith(Observable.fromArray(num4)).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">               System.out.println(integer);  //打印1,2,3,5,6,4,7,8  可能会发生错乱</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       //concatWith：同mergeWith一样，用以合并多个Observable发射的数据，但是concatWith不会让Observable发射的数据交错。</span><br><span class="line">       Integer []num5 = new Integer[]&#123;1,2,3,4,5&#125;;</span><br><span class="line">       Observable.just(5,6,7,8).concatWith(Observable.fromArray(num4)).subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">               System.out.println(integer);  //打印1,2,3,4,5,6,7,8 不会错乱</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="聚合操作符"><a href="#聚合操作符" class="headerlink" title="聚合操作符"></a>聚合操作符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//zipWith：将多个Obversable发射的数据，通过一个函数BiFunction对对应位置的数据处理后放到一个新的Observable中发射，所发射的数据个数与最少的Observabel中的一样多。</span><br><span class="line">       String []colors = new String[]&#123;&quot;黄色&quot;,&quot;红色&quot;,&quot;绿色&quot;,&quot;橙色&quot;,&quot;褐色&quot;,&quot;黑色&quot;&#125;;</span><br><span class="line">       Observable.just(1,2,3,4,5,6,7).zipWith(Observable.fromArray(colors), new BiFunction&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public String apply(Integer integer, String s) throws Exception &#123;</span><br><span class="line">               return integer + s;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribe(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(String s) throws Exception &#123;</span><br><span class="line">               System.out.println(s);  //打印1黄色 2红色 3绿色...6黑色</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Scheduler线程调度器"><a href="#Scheduler线程调度器" class="headerlink" title="Scheduler线程调度器"></a>Scheduler线程调度器</h3><p>Scheduler(线程调度器)赋予RxJava简洁明了的异步操作,可以说是RxJava中最值得称道的地方。Scheduler(线程调度器)可以让RxJava的线程切换变得简单明了，即使程序逻辑变得十分复杂，他依然能够保持简单明了。</p>
<h4 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;T&gt; subscribeOn(Scheduler scheduler)</span><br></pre></td></tr></table></figure>
<p>subscribeOn通过接收一个Scheduler参数，来指定对数据的处理运行在特定的线程调度器Scheduler上。若多次设定，则只有一次起作用。</p>
<h4 id="observeOn"><a href="#observeOn" class="headerlink" title="observeOn"></a>observeOn</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;T&gt; observeOn(Scheduler scheduler)</span><br></pre></td></tr></table></figure>
<p>observeOn同样接收一个Scheduler参数，来指定下游操作运行在特定的线程调度器Scheduler上。若多次设定，每次均起作用。</p>
<h4 id="Scheduler种类"><a href="#Scheduler种类" class="headerlink" title="Scheduler种类"></a>Scheduler种类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Schedulers.io():用于IO密集型的操作，例如读写SD卡文件，查询数据库，访问网络.</span><br><span class="line">Schedulers.newThread()：在每执行一个任务时创建一个新的线程，不具有线程缓存机制，因为创建一个新的线程比复用一个线程更耗时耗力，虽然使用Schedulers.io()的地方，都可以使用Schedulers.newThread()，但是，Schedulers.newThread()的效率没有Schedulers.io()高。</span><br><span class="line">Schedulers.computation()：用于CPU 密集型计算任务，即不会被 I/O 等操作限制性能的耗时操作，</span><br><span class="line">Schedulers.trampoline()：在当前线程立即执行任务，如果当前线程有任务在执行，则会将其暂停，等插入进来的任务执行完之后，再将未完成的任务接着执行。</span><br><span class="line">Schedulers.single()：拥有一个线程单例，所有的任务都在这一个线程中执行，当此线程中有任务执行时，其他任务将会按照先进先出的顺序依次执行。</span><br><span class="line">AndroidSchedulers.mainThread()：在Android UI线程中执行任务，为Android开发定制。</span><br><span class="line">Scheduler.from(@NonNull Executor executor)：指定一个线程调度器，由此调度器来控制任务的执行策略。</span><br></pre></td></tr></table></figure>
<p>以上列出的是rxjava2中所有支持的Scheuler种类，Rxjava1中Schedulers.immediate()被Schedulers.trampoline()替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                for(int i = 0; i&lt;5; i++)&#123;</span><br><span class="line">                    System.out.println(&quot;发射线程:&quot;+Thread.currentThread().getName()+&quot;---&gt;发射&quot;+i);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                    e.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">                e.onComplete();</span><br><span class="line">           &#125;</span><br><span class="line">          &#125;).subscribeOn(Schedulers.io())</span><br><span class="line">               .map(new Function&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public Integer apply(Integer integer) throws Exception &#123;</span><br><span class="line">                       System.out.println(&quot;处理线程:&quot;+Thread.currentThread().getName()+&quot;---&gt;处理&quot;+integer);</span><br><span class="line">                       return integer;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)</span><br><span class="line">               .subscribeOn(Schedulers.newThread())</span><br><span class="line">               .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">               .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                       System.out.println(&quot;接收线程:&quot;+Thread.currentThread().getName()+&quot;---&gt;接收&quot;+integer);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               </span><br><span class="line">//运行结果如下</span><br><span class="line">System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:0</span><br><span class="line">System.out: 处理线程:RxCachedThreadScheduler-1----&gt;处理:0</span><br><span class="line">System.out: 发射线程:RxCachedThreadScheduler-1----&gt;发射:1</span><br><span class="line">System.out: 接收线程:main----&gt;接收:0</span><br><span class="line">System.out: 处理线程:RxCachedThreadScheduler-1----&gt;处理:1</span><br><span class="line">System.out: 接收线程:main----&gt;接收:1</span><br></pre></td></tr></table></figure>
<h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>从上可知，数据流的发射、处理以及响应可能在各自线程中独立进行，上游的发射数据的时候，不知道下游是否处理完，所以会产生一种情况，发送事件的速度大于消费事件的速度，这样就会产生很多待处理的数据，不会被垃圾回收机制回收，而是存放在一个异步的缓存池中，如果缓存池中的数据一直得不到处理，越积越多，最后就会造成内存溢出，这便是背压问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">               int i = 0;</span><br><span class="line">               while(true)&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   e.onNext(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).subscribeOn(Schedulers.newThread())</span><br><span class="line">               .observeOn(Schedulers.newThread())</span><br><span class="line">               .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">              Thread.sleep(3000);</span><br><span class="line">               System.out.println(integer);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p>
<p>创建一个可观察对象Obervable在Schedulers.newThread()()的线程中不断发送数据，而观察者Observer在Schedulers.newThread()的另一个线程中每隔3秒接收一条数据，运行后，查看内存使用如下图：</p>
<p><img src="/img/pl/rxjava2_backpressure.gif" alt=""></p>
<p>由于上下游分别在各自的线程中独立处理数据（如果上下游在同一线程中，下游对数据的处理会堵塞上游数据的发送，上游发送一条数据后会等下游处理完之后再发送下一条），而上游发送数据速度远大于下游接收数据的速度，造成上下游流速不均，导致数据累计，最后引起内存溢出。</p>
<h4 id="Flowable"><a href="#Flowable" class="headerlink" title="Flowable"></a>Flowable</h4><p>Flowable是为了解决背压（backpressure）问题，而在Observable的基础上优化后的产物，与Observable不是同一组观察者模式下的成员，Flowable是Publisher与Subscriber这一组观察者模式中Publisher的典型实现，Observable是ObservableSource/Observer这一组观察者模式中ObservableSource的典型实现。</p>
<p>既然Flowable是在Observable的基础上优化后的产物，Observable能解决的问题Flowable都能进行解决，何不抛弃Observable而只用Flowable呢。其实，这是万万不可的，他们各有自己的优势和不足。由于基于Flowable发射的数据流，以及对数据加工处理的各操作符都添加了背压支持，附加了额外的逻辑，其运行效率要比Observable低得多。</p>
<p>因为只有上下游运行在各自的线程中，且上游发射数据速度大于下游接收处理数据的速度时，才会产生背压问题。<br>所以，如果能够确定上下游在同一个线程中工作，或者上下游工作在不同的线程中，而下游处理数据的速度高于上游发射数据的速度，则不会产生背压问题，就没有必要使用Flowable，以免影响性能。</p>
<h4 id="背压策略"><a href="#背压策略" class="headerlink" title="背压策略"></a>背压策略</h4><p>Flowable的异步缓存池不同于Observable，Observable的异步缓存池没有大小限制，可以无限制向里添加数据，直至OOM,而Flowable的异步缓存池有个固定容量，其大小为128。<br>BackpressureStrategy的作用便是用来设置Flowable通过异步缓存池存储数据的策略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">ERROR:在此策略下，如果放入Flowable的异步缓存池中的数据超限了，则会抛出MissingBackpressureException异常。</span><br><span class="line"></span><br><span class="line">DROP:在此策略下，如果Flowable的异步缓存池满了，会丢掉将要放入缓存池中的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BUFFER:此策略下，Flowable的异步缓存池同Observable的一样，没有固定大小，可以无限制向里添加数据，不会抛出MissingBackpressureException异常，但会导致OOM。</span><br><span class="line"></span><br><span class="line">MISSING:此策略表示，通过Create方法创建的Flowable没有指定背压策略，不会对通过OnNext发射的数据做缓存或丢弃处理，需要下游通过背压操作符（onBackpressureBuffer()/onBackpressureDrop()/onBackpressureLatest()）指定背压策略。</span><br><span class="line"></span><br><span class="line">LATEST:与Drop策略一样，如果缓存池满了，会丢掉将要放入缓存池中的数据，不同的是，不管缓存池的状态如何，LATEST都会将最后一条数据强行放入缓存池中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">                for(int i = 0; i&lt;500; i++)&#123;</span><br><span class="line">                    e.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">                e.onComplete();</span><br><span class="line">            &#125;</span><br><span class="line">            //具体背压策略替换这里即可</span><br><span class="line">        &#125;, BackpressureStrategy.BUFFER)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                        System.out.println(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">        //onBackpressureXXX背压操作符</span><br><span class="line">        //Flowable除了通过create创建的时候指定背压策略，也可以在通过其它创建操作符just，fromArray等创建后通过背压操作符指定背压策略。</span><br><span class="line">        //onBackpressureBuffer()对应BackpressureStrategy.BUFFER</span><br><span class="line">        //onBackpressureDrop()对应BackpressureStrategy.DROP</span><br><span class="line">        //onBackpressureLatest()对应BackpressureStrategy.LATEST</span><br><span class="line">        //这个与上面Flowable.create()方式创建效果是一样的</span><br><span class="line">        Flowable.range(0, 500)</span><br><span class="line">                .onBackpressureBuffer()</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(new Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void accept(Integer integer) throws Exception &#123;</span><br><span class="line">                        System.out.println(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>所以结合FlowableEmitter与Subscription，通过设置处理请求量(subscription.request)以及动态获取待处理请求量(FlowableEmitter.requested())，对Flowable做出改进，让其不会产生背压问题，也不会引起异常或者数据丢失。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void subscribe(FlowableEmitter&lt;Integer&gt; e) throws Exception &#123;</span><br><span class="line">               int i = 0;</span><br><span class="line">               while(true)&#123;</span><br><span class="line">                   //e.requested()获取下游未处理的事件量</span><br><span class="line">                   if(e.requested() == 0) continue;   //此处添加代码，让Flowable按需添加代码</span><br><span class="line">                   System.out.println(&quot;发射---&gt;&quot;+i);</span><br><span class="line">                   i++;</span><br><span class="line">                   e.onNext(i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, BackpressureStrategy.MISSING)</span><br><span class="line">               .subscribeOn(Schedulers.newThread())</span><br><span class="line">               .observeOn(Schedulers.newThread())</span><br><span class="line">               .subscribe(new Subscriber&lt;Integer&gt;() &#123;</span><br><span class="line">                   Subscription subscription;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void onSubscribe(Subscription s) &#123;</span><br><span class="line">                      //s.request设置可处理的事件量，默认为0不进行处理</span><br><span class="line">                       s.request(1);   //设置初始请求数据为1</span><br><span class="line">                       subscription = s;</span><br><span class="line">                   &#125;</span><br><span class="line">                   @Override</span><br><span class="line">                   public void onNext(Integer integer) &#123;</span><br><span class="line">                       try &#123;</span><br><span class="line">                           Thread.sleep(1000);</span><br><span class="line">                           System.out.println(&quot;接收---&gt;&quot;+integer);</span><br><span class="line">                           subscription.request(1);//每接收到一条请求就增加一条请求量</span><br><span class="line">                       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                           e.printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onError(Throwable t) &#123;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   @Override</span><br><span class="line">                   public void onComplete() &#123;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Observable简化版之Single、Comoplable以及Maybe"><a href="#Observable简化版之Single、Comoplable以及Maybe" class="headerlink" title="Observable简化版之Single、Comoplable以及Maybe"></a>Observable简化版之Single、Comoplable以及Maybe</h3><p>在Rxjava2中，Observale和Flowable都是用来发射数据流的，但是，我们在实际应用中，很多时候，需要发射的数据并不是数据流的形式，而只是一条单一的数据，或者一条完成通知，或者一条错误通知。在这种情况下，我们再使用Observable或者Flowable就显得有点大材小用，于是，为了满足这种单一数据或通知的使用场景，便出现了Observable的简化版——Single、Completable、Maybe。</p>
<h4 id="Single"><a href="#Single" class="headerlink" title="Single"></a>Single</h4><p>只发射一条单一的数据，或者一条异常通知，不能发射完成通知，其中数据与通知只能发射一个。</p>
<h4 id="Completable"><a href="#Completable" class="headerlink" title="Completable"></a>Completable</h4><p>只发射一条完成通知，或者一条异常通知，不能发射数据，其中完成通知与异常通知只能发射一个</p>
<h4 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h4><p>可发射一条单一的数据，以及发射一条完成通知，或者一条异常通知，其中完成通知和异常通知只能发射一个，发射数据只能在发射完成通知或者异常通知之前，否则发射数据无效。</p>
<p>三者的调用方式与Observable类似，只是create方法中传递的对象不同而已，由于篇幅有限，这边就不给出代码示例，具体可参考：<a href="https://www.jianshu.com/p/66a55abbadef" target="_blank" rel="noopener">https://www.jianshu.com/p/66a55abbadef</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于Rxjava2学习总结，关于背压这块我介绍的可能不是很清楚，可参照以下博客。</p>
<p>背压介绍：<a href="https://www.jianshu.com/p/ff8167c1d191" target="_blank" rel="noopener">https://www.jianshu.com/p/ff8167c1d191</a></p>
<p>示例代码：<a href="https://github.com/penglian/Rxjava2Demo/" target="_blank" rel="noopener">https://github.com/penglian/Rxjava2Demo/</a></p>
</div><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/rxjava2/">rxjava2</a><a href="/tags/响应函数式/">响应函数式</a><a href="/tags/背压/">背压</a></div><div class="post-nav"><a class="pre" href="/2018/07/26/Mini_Program/">Mini Program初探</a><a class="next" href="/2018/07/16/javascript_start/">js函数深入研究</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://xybank.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/余声赞/">余声赞</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/余硕/">余硕</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/匡利金/">匡利金</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/卓平/">卓平</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/卢文才/">卢文才</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/张杨/">张杨</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/张永枫/">张永枫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/彭连/">彭连</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/方振养/">方振养</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/李关浩/">李关浩</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/李志丹/">李志丹</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杨新才/">杨新才</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/洪宇杰/">洪宇杰</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/甘明阳/">甘明阳</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/甘潇敏/">甘潇敏</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/童长钱/">童长钱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/蔡向炜/">蔡向炜</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/薛玉博/">薛玉博</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/赖钧/">赖钧</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/高兰花/">高兰花</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/黄涛/">黄涛</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Messenger/" style="font-size: 15px;">Messenger</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Rss/" style="font-size: 15px;">Rss</a> <a href="/tags/HTML5/" style="font-size: 15px;">HTML5</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/JavaScript，closure/" style="font-size: 15px;">JavaScript，closure</a> <a href="/tags/js，定时器/" style="font-size: 15px;">js，定时器</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/string/" style="font-size: 15px;">string</a> <a href="/tags/微信小程序/" style="font-size: 15px;">微信小程序</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/Mybatis/" style="font-size: 15px;">Mybatis</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/Nodejs/" style="font-size: 15px;">Nodejs</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/阿里云/" style="font-size: 15px;">阿里云</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Activity/" style="font-size: 15px;">Activity</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/file/" style="font-size: 15px;">file</a> <a href="/tags/Android-P/" style="font-size: 15px;">Android P</a> <a href="/tags/兼容适配/" style="font-size: 15px;">兼容适配</a> <a href="/tags/可读性/" style="font-size: 15px;">可读性</a> <a href="/tags/代码/" style="font-size: 15px;">代码</a> <a href="/tags/Bitmap/" style="font-size: 15px;">Bitmap</a> <a href="/tags/WeChat/" style="font-size: 15px;">WeChat</a> <a href="/tags/DingDing/" style="font-size: 15px;">DingDing</a> <a href="/tags/deviceId/" style="font-size: 15px;">deviceId</a> <a href="/tags/SharePreference/" style="font-size: 15px;">SharePreference</a> <a href="/tags/File/" style="font-size: 15px;">File</a> <a href="/tags/Jenkins/" style="font-size: 15px;">Jenkins</a> <a href="/tags/IPC/" style="font-size: 15px;">IPC</a> <a href="/tags/Binder/" style="font-size: 15px;">Binder</a> <a href="/tags/AIDL/" style="font-size: 15px;">AIDL</a> <a href="/tags/Fiddler/" style="font-size: 15px;">Fiddler</a> <a href="/tags/MVP/" style="font-size: 15px;">MVP</a> <a href="/tags/设计架构/" style="font-size: 15px;">设计架构</a> <a href="/tags/rxjava/" style="font-size: 15px;">rxjava</a> <a href="/tags/retrofit/" style="font-size: 15px;">retrofit</a> <a href="/tags/okhttp/" style="font-size: 15px;">okhttp</a> <a href="/tags/rxjava2/" style="font-size: 15px;">rxjava2</a> <a href="/tags/响应函数式/" style="font-size: 15px;">响应函数式</a> <a href="/tags/背压/" style="font-size: 15px;">背压</a> <a href="/tags/Serializable/" style="font-size: 15px;">Serializable</a> <a href="/tags/Parcelable/" style="font-size: 15px;">Parcelable</a> <a href="/tags/bootstrap/" style="font-size: 15px;">bootstrap</a> <a href="/tags/css，布局/" style="font-size: 15px;">css，布局</a> <a href="/tags/css3/" style="font-size: 15px;">css3</a> <a href="/tags/css3，flexbox/" style="font-size: 15px;">css3，flexbox</a> <a href="/tags/CSS的字体适配/" style="font-size: 15px;">CSS的字体适配</a> <a href="/tags/erlang/" style="font-size: 15px;">erlang</a> <a href="/tags/ewp中模拟报文的使用/" style="font-size: 15px;">ewp中模拟报文的使用</a> <a href="/tags/form表单，html5/" style="font-size: 15px;">form表单，html5</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/java，集合/" style="font-size: 15px;">java，集合</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/js，with/" style="font-size: 15px;">js，with</a> <a href="/tags/xhtml-lua/" style="font-size: 15px;">xhtml+lua</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/vi的编辑/" style="font-size: 15px;">vi的编辑</a> <a href="/tags/lua/" style="font-size: 15px;">lua</a> <a href="/tags/app/" style="font-size: 15px;">app</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/tags/nodejs/" style="font-size: 15px;">nodejs</a> <a href="/tags/photoshop/" style="font-size: 15px;">photoshop</a> <a href="/tags/xq/" style="font-size: 15px;">xq</a> <a href="/tags/3种定位的使用/" style="font-size: 15px;">3种定位的使用</a> <a href="/tags/js中两种定时器的设置及清除/" style="font-size: 15px;">js中两种定时器的设置及清除</a> <a href="/tags/yaws/" style="font-size: 15px;">yaws</a> <a href="/tags/web/" style="font-size: 15px;">web</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/07/blog_code_readability_Github/">关于代码可读性的一些见解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/26/Mini_Program/">Mini Program初探</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/18/blog_rxjava2_github/">Rxjava2学习总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/16/javascript_start/">js函数深入研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/11/Git_filter_branch/">Git删除历史记录中的大文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/blog_combine_bitmap/">CombineBitmap开源项目源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/java_yzm/">java发送手机短信认证码</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/Bootstrap Carousel/">Bootstrap 轮播（Carousel）插件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/05/css-my experience/">css那些我踩过的坑-1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/29/blog_deviceId_GitHub/">对于获取设备标识的简述</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">融易通兴业团队.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>